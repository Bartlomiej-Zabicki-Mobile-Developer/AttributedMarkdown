{
  "title": "What’s the difference between @ObservedObject, @State, and @EnvironmentObject?",
  "author": null,
  "date_published": null,
  "dek": null,
  "lead_image_url": null,
  "content": "[Paul Hudson](/about)    [@twostraws](https://twitter.com/twostraws)    September 3rd 2021\n\n_Updated for Xcode 13.2_\n\nState is inevitable in any modern app, but with SwiftUI it’s important to remember that all of our views are simply functions of their state – we don’t change the views directly, but instead manipulate the state and let _that_ dictate the result.\n\nSwiftUI gives us several ways of storing state in our application, but they are subtly different and it’s important to understand _how_ they are different in order to use the framework properly.\n\nThe simplest way of working with state is the `@State` property wrapper, used like this:\n\n    struct ContentView: View {\n        @State private var tapCount = 0\n    \n        var body: some View {\n            Button(\"Tap count: \\(tapCount)\") {\n                tapCount += 1\n            }\n        }\n    }\n\n [![](/img/xcode-icon.png) Download this as an Xcode project](/files/projects/swiftui/whats-the-difference-between-atobservedobject-atstate-and-atenvironmentobject-1.zip)\n\nThis creates a property inside a view, but it uses the `@State` property wrapper to ask SwiftUI to manage the memory. This _matters_: all our views are structs, which means they can’t be changed, and if we weren’t even able to modify an integer in our apps then there wouldn’t be much we _could_ do.\n\nSo, when we say `@State` to make a property, we hand control over it to SwiftUI so that it remains persistent in memory for as long as the view exists. When that state changes, SwiftUI knows to automatically reload the view with the latest changes so it can reflect its new information.\n\n`@State` is great for simple properties that belong to a specific view and never get used outside that view, so as a result it’s important to mark those properties as being private to re-enforce the idea that such state is specifically designed never to escape its view.\n\nWhat is @ObservedObject?\n------------------------\n\nFor more complex properties – when you have a custom type you want to use that might have multiple properties and methods, or might be shared across multiple views – you will often use `@ObservedObject` instead.\n\nThis is very similar to `@State` except now we’re using an external reference type rather than a simple local property like a string or an integer. You’re still saying that your view depends on data that will change, except now it’s data you’re responsible for managing yourself – you need to create an instance of the class, create its own properties, and so on.\n\nWhatever type you use with `@ObservedObject` should conform to the `ObservableObject` protocol. When you add properties to observable objects you get to decide whether changes to each property should force views that are watching your object to refresh or not. You usually will, but it’s not required.\n\nThere are several ways for an observed object to notify views that important data has changed, but the easiest is using the `@Published` property wrapper. You can also use custom publishers from the Combine framework if you need more control, but realistically this will be very rare. If the observable object happens to have several views using its data, either option will automatically notify them all.\n\n**Warning:** When you use a custom publisher to announce that your object has changed, this _must_ happen on the main thread.\n\nWhat is @StateObject?\n---------------------\n\nSomewhere between `@State` and `@ObservedObject` lies `@StateObject`. This is a specialized version of `@ObservedObject`, and it works in almost exactly the same way: you must conform to the `ObservableObject` protocol, you can use `@Published` to mark properties as causing change notifications, and any views that watch an `@StateObject` will refresh their body when the object changes.\n\nThere is one important difference between `@StateObject` and `@ObservedObject`, which is _ownership_ – which view _created_ the object, and which view is just _watching_ it.\n\nThe rule is this: whichever view is the first to create your object must use `@StateObject`, to tell SwiftUI it is the owner of the data and is responsible for keeping it alive. All other views must use `@ObservedObject`, to tell SwiftUI they want to watch the object for changes but don’t own it directly.\n\nWhat is @EnvironmentObject?\n---------------------------\n\nYou’ve seen how `@State` declares simple properties for a type that automatically cause a refresh of the view when it changes, and how `@ObservedObject` declares a property for an external type that may or may not cause a refresh of the view when it changes. Both of these two must be set by your view, but `@ObservedObject` might be shared with other views.\n\nThere’s another type of property wrapper available to use, which is `@EnvironmentObject`. This is a value that is made available to your views through the application itself – it’s shared data that every view can read if they want to. So, if your app had some important model data that all views needed to read, you could either hand it from view to view to view or just put it into the environment where every view has instant access to it.\n\nThink of `@EnvironmentObject` as a massive convenience for times when you need to pass lots of data around your app. Because all views point to the same model, if one view changes the model all views immediately update – there’s no risk of getting different parts of your app out of sync.\n\nSumming up the differences\n--------------------------\n\n*   Use `@State` for simple properties that belong to a single view. They should usually be marked `private`.\n*   Use `@ObservedObject` for complex properties that might belong to several views. Most times you’re using a reference type you should be using `@ObservedObject` for it.\n*   Use `@StateObject` once for each observable object you use, in whichever part of your code is responsible for creating it.\n*   Use `@EnvironmentObject` for properties that were created elsewhere in the app, such as shared data.\n\nOf the four you will find that `@ObservedObject` is both the most useful and the most commonly used, so if you’re not sure which to use start there.\n\n[Sponsor Hacking with Swift and reach the world's largest Swift community!](/sponsor)\n\n### Similar solutions…",
  "next_page_url": null,
  "url": "https://www.hackingwithswift.com/quick-start/swiftui/whats-the-difference-between-observedobject-state-and-environmentobject",
  "domain": "www.hackingwithswift.com",
  "excerpt": "Paul Hudson @twostraws September 3rd 2021 Updated for Xcode 13.2State is inevitable in any modern app, but with SwiftUI it’s important to remember that all of our views are simply functions of their&hellip;",
  "word_count": 981,
  "direction": "ltr",
  "total_pages": 1,
  "rendered_pages": 1
}
