{
  "title": "Sendable and @Sendable closures explained with code examples",
  "author": null,
  "date_published": "2021-10-19T09:02:24.000Z",
  "dek": null,
  "lead_image_url": "https://swiftlee-banners.herokuapp.com/imagegenerator.php?title=Sendable+and+%40Sendable+closures+explained+with+code+examples",
  "content": "Sendable and @Sendable are part of the concurrency changes that arrived in Swift 5.5 and address a challenging problem of type checking values passed between structured concurrency constructs and actor messages.\n\nBefore diving into the topic of sendables, I encourage you to read up on my articles around [async/await](https://www.avanderlee.com/swift/async-await/), [actors](https://www.avanderlee.com/swift/actors/), and [actor isolation](https://www.avanderlee.com/swift/nonisolated-isolated/). These articles cover the basics of the new concurrency changes, which directly connect to the techniques explained in this article.\n\nIncrease your application's performance with rich context about errors and slowdowns in your iOS applications. [**Get started**](http://sentry.io/signup?utm_source=swiftlee&utm_campaign=ios-q1&utm_medium=paid-sponsorship&utm_content=docs) with **2 free months** of Sentry’s Business Plan (the best one) with code: **SWIFTLEE**\n\n[](#when-should-i-use-sendable)When should I use Sendable?\n----------------------------------------------------------\n\nThe Sendable protocol and closure indicate whether the public API of the passed values passed thread-safe to the compiler. A public API is safe to use across concurrency domains when there are no public mutators, an internal locking system is in place, or mutators implement copy on write like with value types.\n\nMany types of the standard library already support the Sendable protocol, taking away the requirement to add conformance to many types. As a result of the standard library support, the compiler can implicitly create support for your custom types.\n\nFor example, integers support the protocol:\n\n    extension Int: Sendable {}\n\nOnce we create a value type struct with a single property of type int, we implicitly get support for the Sendable protocol:\n\n    // Implicitly conforms to Sendable\n    struct Article {\n        var views: Int\n    }\n\nAt the same time, the following class example of the same article would not have implicit conformance:\n\n    // Does not implicitly conform to Sendable\n    class Article {\n        var views: Int\n    }\n\nThe class does not conform because it is a reference type and therefore mutable from other concurrent domains. In other words, the class article is not thread-safe to pass around, and the compiler can’t implicitly mark it as Sendable.\n\n### [](#implicit-conformance-when-using-generics-and-enums)Implicit conformance when using generics and enums\n\nIt’s good to understand that the compiler does not add implicit conformance to generic types if the generic type does not conform to Sendable.\n\n    // No implicit conformance to Sendable because Value does not conform to Sendable\n    struct Container<Value> {\n        var child: Value\n    }\n\nHowever, if we add a protocol requirement to our generic value, we will get implicit support:\n\n    // Container implicitly conforms to Sendable as all its public properties do so too.\n    struct Container<Value: Sendable> {\n        var child: Value\n    }\n\nThe same counts for enums with associated values:\n\n![Implicit Sendable protocol conformance won't work if children do not conform to Sendable.](https://www.avanderlee.com/wp-content/uploads/2021/10/sendable_protocol_swift-1024x183.png)\n\nImplicit Sendable protocol conformance won’t work if children do not conform to Sendable.\n\nYou can see that we automatically get an error by the compiler:\n\n> Associated value ‘loggedIn(name:)’ of ‘Sendable’-conforming enum ‘State’ has non-sendable type ‘(name: NSAttributedString)’\n\nWe can solve the error by using a value type `String` instead, as it already conforms to Sendable:\n\n    enum State: Sendable {\n        case loggedOut\n        case loggedIn(name: String)\n    }\n\n### [](#throwing-errors-from-a-thread-safe-instances)Throwing errors from a thread-safe instances\n\nThe same rules apply to errors that want to conform to Sendable:\n\n    struct ArticleSavingError: Error {\n        var author: NonFinalAuthor\n    }\n    \n    extension ArticleSavingError: Sendable { }\n\nAs the author is non-final and not thread-safe (more about that later), we will run into the following error:\n\n> Stored property ‘author’ of ‘Sendable’-conforming struct ‘ArticleSavingError’ has non-sendable type ‘NonFinalAuthor’\n\nYou can solve the error by making sure all members of `ArticleSavingError` conform to Sendable.\n\n[](#how-to-use-the-sendable-protocol)How to use the Sendable protocol\n---------------------------------------------------------------------\n\nImplicit conformance takes away a lot of cases in which we need to add conformance to the Sendable protocol ourselves. However, there are cases in which the compiler does not add implicit conformance while we know that our type is thread-safe.\n\nCommon examples of types that are not implicitly sendable but can be marked as such are immutable classes and classes with internal locking mechanisms:\n\n    /// User is immutable and therefore thread-safe, so can conform to Sendable\n    final class User: Sendable {\n        let name: String\n    \n        init(name: String) { self.name = name }\n    }\n\nMutable classes need to be marked with the `@unchecked` attribute to indicate our class is actually thread-safe due to internal locking mechanisms:\n\n    extension DispatchQueue {\n        static let userMutatingLock = DispatchQueue(label: \"person.lock.queue\")\n    }\n    \n    final class MutableUser: @unchecked Sendable {\n        private var name: String = \"\"\n    \n        func updateName(_ name: String) {\n            DispatchQueue.userMutatingLock.sync {\n                self.name = name\n            }\n        }\n    }\n\n[](#the-restriction-of-conforming-to-sendable-in-the-same-source-file)The restriction of conforming to Sendable in the same source file\n---------------------------------------------------------------------------------------------------------------------------------------\n\nSendable protocol conformance must happen within the same source file to ensure that the compiler checks all visible members for thread safety.\n\nFor example, you could define the following type within a module like a Swift package:\n\n    public struct Article {\n        internal var title: String\n    }\n\nThe article itself is public, while the title is internal and not visible outside the module. Therefore, the compiler can’t apply Sendable conformance outside of the source file as it has no visibility of the title property, even though the title is using a Sendable type `String`.\n\nThe same problem occurs when trying to conform an immutable non-final class to Sendable:\n\n![Non-final immutable classes can't conform to Sendable](https://www.avanderlee.com/wp-content/uploads/2021/10/non_final_sendable-1024x185.png)\n\nNon-final immutable classes can’t conform to Sendable\n\nSince the class is non-final we can’t conform to Sendable as we’re unsure whether other classes will inherit from `User` with non-Sendable members. Therefore, we would run into the following error:\n\n> Non-final class ‘User’ cannot conform to \\`Sendable\\`; use \\`@unchecked Sendable\\`\n\nAs you can see, the compiler suggests using `@unchecked Sendable`. We can add this attribute to our user instance and get rid of the error:\n\n    class User: @unchecked Sendable {\n        let name: String\n    \n        init(name: String) { self.name = name }\n    }\n\nHowever, this does require us to ensure it’s always thread-safe whenever we inherit from `User`. As we add extra responsibility to ourselves and our colleagues, I would discourage using this attribute instead of using composition, final classes, or value types.\n\n[](#how-to-use-sendable)How to use @Sendable\n--------------------------------------------\n\nFunctions can be passed across concurrency domains and will therefore require sendable conformance too. However, functions can’t conform to protocols which is why the @Sendable attribute is introduced. Examples of functions that you can pass around are global function declarations, closures, and accessors like getters and setters.\n\nPart of the motivation of [SE-302](https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md) is performing as little synchronization as possible:\n\n> we want the vast majority of code in such a system to be synchronization free\n\nBy using the @Sendable attribute we will tell the compiler that no extra synchronization is needed as all captured values in the closure are thread-safe to work with. A typical example would be using closures from within [Actor isolation](https://www.avanderlee.com/swift/nonisolated-isolated/):\n\n    actor ArticlesList {\n        func filteredArticles(_ isIncluded: @Sendable (Article) -> Bool) async -> [Article] {\n            // ...\n        }\n    }\n\nIn case you would use the closure with a non-sendable type, we would run into an error:\n\n    let listOfArticles = ArticlesList()\n    var searchKeyword: NSAttributedString? = NSAttributedString(string: \"keyword\")\n    let filteredArticles = await listOfArticles.filteredArticles { article in\n     \n        // Error: Reference to captured var 'searchKeyword' in concurrently-executing code\n        guard let searchKeyword = searchKeyword else { return false }\n        return article.title == searchKeyword.string\n    }\n\nOf course, we can quickly solve this case by just using a regular `String` instead, but it does demonstrate how the compiler helps us to enforce thread safety.\n\n[](#continuing-your-journey-into-swift-concurrency)Continuing your journey into Swift Concurrency\n-------------------------------------------------------------------------------------------------\n\nThe concurrency changes are more than just async-await and include many new features that you can benefit from in your code. Now that you’ve learned about Sendable, it’s time to dive into other concurrency features:\n\nIncrease your application's performance with rich context about errors and slowdowns in your iOS applications. [**Get started**](http://sentry.io/signup?utm_source=swiftlee&utm_campaign=ios-q1&utm_medium=paid-sponsorship&utm_content=docs) with **2 free months** of Sentry’s Business Plan (the best one) with code: **SWIFTLEE**\n\n### [](#conclusion)Conclusion\n\nThe Sendable protocol and @Sendable attribute for functions make it possible to tell the compiler about thread safety when working with concurrency in Swift. Both features were introduced to reach the bigger goal of the Swift Concurrency effort, which is providing a mechanism to isolate states in concurrent programs to eliminate [data races](https://www.avanderlee.com/swift/thread-sanitizer-data-races/). The compiler will help us in many cases with implicit conformance to Sendable, but we can always add conformance ourselves.\n\nIf you like to learn more tips on Swift, check out the [Swift category page](https://www.avanderlee.com/category/swift/). Feel free to [contact me](mailto:contact@avanderlee.com) or tweet me on Twitter if you have any additional suggestions or feedback.\n\nThanks!",
  "next_page_url": null,
  "url": "https://www.avanderlee.com/swift/sendable-protocol-closures/",
  "domain": "www.avanderlee.com",
  "excerpt": "The Sendable protocol and @Sendable attribute help to eliminate data races and create thread-safety in Swift Concurrency.",
  "word_count": 31,
  "direction": "ltr",
  "total_pages": 1,
  "rendered_pages": 1
}
