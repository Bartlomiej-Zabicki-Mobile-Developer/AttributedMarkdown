{
  "title": "iOS Crash Symbolication for dummies Part 1",
  "author": "Dmitry Fink",
  "date_published": "2017-03-08T23:41:56.000Z",
  "dek": null,
  "lead_image_url": "https://www.bugsee.com/wp-content/themes/bugsee/assets/logos/logo512.png",
  "content": "Many developers use Bugsee for its great crash reporting capabilities. In fact, Bugsee crash reporting has recently been [ranked the highest](http://www.crashprobe.com/ios/) among all iOS crash reporting services when it comes to accuracy and the amount of details in the report. Bugsee doesn’t stop there, however, it also presents video of user actions, console logs and network traffic that preceded the crash.\n\nIn the following series of posts we are actually going to focus on the crash log itself, explain the magic behind it and show how to properly set it up.\n\n_First post in the series is an introductory one. _\n\nWhat is symbolication?\n----------------------\n\nIn order to answer that question we must briefly touch on the build process itself. Regardless of the language our project is written in (be that Objective C, Swift or any other), the build process translates our human readable code into machine binary code. Consider the following buggy code (can you spot the bug?).\n\nvoid initialize() { array = @\\[@\"one\", @\"two\", @\"three\"\\]; } NSNumber\\* getElementFromArray(int index) { return array\\[index\\]; } void printAllElements() { for (int i = 0; i <= 3; i++) { NSLog(@\"%@\", getElementFromArray(i)); } }\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\nvoid  initialize()  {\n\n array  \\=  @\\[@\"one\",  @\"two\",  @\"three\"\\];\n\n}\n\nNSNumber\\*  getElementFromArray(int  index)  {\n\nreturn  array\\[index\\];\n\n}\n\nvoid  printAllElements()  {\n\nfor  (int  i  \\=  0;  i  <\\=  3;  i++)  {\n\nNSLog(@\"%@\",  getElementFromArray(i));\n\n}\n\n}\n\nAfter build it will eventually become this:\n\n0x100117dec: stp x29, x30, \\[sp, #-16\\]! ; <--- Start of the initialize() method <...skipped...> 0x100117e9c: ldp x29, x30, \\[sp\\], #16 0x100117ea0: ret 0x100117ea4: bl 0x10022d83c 0x100117ea8: stp x29, x30, \\[sp, #-16\\]! ; <--- Start of the printAllElements() method 0x100117eac: mov x29, sp 0x100117eb0: sub sp, sp, #32 0x100117eb4: stur wzr, \\[x29, #-4\\] 0x100117eb8: ldur w8, \\[x29, #-4\\] 0x100117ebc: cmp w8, #3 0x100117ec0: b.gt 0x100117f08 0x100117ec4: ldur w0, \\[x29, #-4\\] 0x100117ec8: bl 0x100117f14 ; <---- this is where it calls getElementFromArray() 0x100117ecc: mov x29, x29 0x100117ed0: bl 0x10022d668 <...skipped...> 0x100117f0c: ldp x29, x30, \\[sp\\], #16 0x100117f10: ret 0x100117f14: stp x29, x30, \\[sp, #-16\\]! ; <--- Start of getElementFromArray() method 0x100117f18: mov x29, sp 0x100117f1c: sub sp, sp, #16 0x100117f20: adrp x8, 436 0x100117f24: add x8, x8, #2520 0x100117f28: adrp x9, 452 0x100117f2c: add x9, x9, #1512 0x100117f30: stur w0, \\[x29, #-4\\] 0x100117f34: ldr x9, \\[x9\\] 0x100117f38: ldursw x2, \\[x29, #-4\\] 0x100117f3c: ldr x1, \\[x8\\] 0x100117f40: mov x0, x9 0x100117f44: bl 0x10022d608 ; <--- Here we send message to NSArray to retrive that element 0x100117f48: mov sp, x29 0x100117f4c: ldp x29, x30, \\[sp\\], #16 0x100117f50: ret\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n30\n\n31\n\n32\n\n33\n\n34\n\n35\n\n    0x100117dec:  stpx29,  x30,  \\[sp,  #-16\\]! ; <--- Start of the initialize() method\n\n<...skipped...\\>\n\n    0x100117e9c:  ldpx29,  x30,  \\[sp\\],  #16\n\n    0x100117ea0:  ret\n\n    0x100117ea4:  bl 0x10022d83c\n\n    0x100117ea8:  stpx29,  x30,  \\[sp,  #-16\\]! ; <--- Start of the printAllElements() method\n\n    0x100117eac:  movx29,  sp\n\n    0x100117eb0:  subsp,  sp,  #32\n\n    0x100117eb4:  stur wzr,  \\[x29,  #-4\\]\n\n    0x100117eb8:  ldur w8,  \\[x29,  #-4\\]\n\n    0x100117ebc:  cmpw8,  #3\n\n    0x100117ec0:  b.gt 0x100117f08\n\n    0x100117ec4:  ldur w0,  \\[x29,  #-4\\]\n\n    0x100117ec8:  bl 0x100117f14 ; <---- this is where it calls getElementFromArray()\n\n    0x100117ecc:  movx29,  x29\n\n    0x100117ed0:  bl 0x10022d668\n\n<...skipped...\\>\n\n    0x100117f0c:  ldpx29,  x30,  \\[sp\\],  #16\n\n    0x100117f10:  ret\n\n    0x100117f14:  stpx29,  x30,  \\[sp,  #-16\\]! ; <--- Start of getElementFromArray() method\n\n    0x100117f18:  movx29,  sp\n\n    0x100117f1c:  subsp,  sp,  #16\n\n    0x100117f20:  adrp x8,  436\n\n    0x100117f24:  addx8,  x8,  #2520\n\n    0x100117f28:  adrp x9,  452\n\n    0x100117f2c:  addx9,  x9,  #1512\n\n    0x100117f30:  stur w0,  \\[x29,  #-4\\]\n\n    0x100117f34:  ldrx9,  \\[x9\\]\n\n    0x100117f38:  ldursw  x2,  \\[x29,  #-4\\]\n\n    0x100117f3c:  ldrx1,  \\[x8\\]\n\n    0x100117f40:  movx0,  x9\n\n    0x100117f44:  bl 0x10022d608 ; <--- Here we send message to NSArray to retrive that element\n\n    0x100117f48:  movsp,  x29\n\n    0x100117f4c:  ldpx29,  x30,  \\[sp\\],  #16\n\n    0x100117f50:  ret\n\nAs you can see from this example, the build process got rid of all the symbols (variable and method names), it also doesn’t know anymore anything about the layout of our code, the amount if spaces we put to separate the functions, all that information is lost. So now when crash occurs (and it will occur, after all we access elements beyond the bounds of that array), if we don’t have symbolication properly set up, this is the only crash information we will end up with:\n\nNSRangeException: \\*\\*\\* -\\[\\_\\_NSArrayI objectAtIndex:\\]: index 3 beyond bounds \\[0 .. 2\\] 0 CoreFoundation 0x1857A51B8 1 libobjc.A.dylib 0x1841DC55C 2 CoreFoundation 0x1856807F4 3 MyApplication 0x100117f48 4 MyApplication 0x100117ecc 5 ...\n\nNSRangeException: \\*\\*\\* -\\[\\_\\_NSArrayI objectAtIndex:\\]: index 3 beyond bounds \\[0 .. 2\\]\n\n0 CoreFoundation      0x1857A51B8\n\n1 libobjc.A.dylib     0x1841DC55C\n\n2 CoreFoundation      0x1856807F4\n\n3 MyApplication       0x100117f48\n\n4 MyApplication       0x100117ecc\n\n5 ...\n\nThis is pretty raw, and not very useful. We know it failed in some method inside the CoreFoundation system method, which was in turn called from some method in libobjc.A.dylib, which was in turn called from another method in CoreFoundation, which in turn was called from our application (finally!). But what is 0x100117f48? Where exactly is it? What file, function or line number is it? That is exactly where symbolication comes in.\n\n> Symbolication is the process of translating the return addresses back into human readable method/filename and line numbers.\n\nSuccessful symbolication will result in the following report instead:\n\nNSRangeException: \\*\\*\\* -\\[\\_\\_NSArrayI objectAtIndex:\\]: index 3 beyond bounds \\[0 .. 2\\] 0 CoreFoundation \\_\\_exceptionPreprocess + 124 1 libobjc.A.dylib objc\\_exception\\_throw + 52 2 CoreFoundation -\\[\\_\\_NSArrayI objectAtIndex:\\] + 180 3 MyApplication getElementFromArray (MyFile.m:22) 4 MyApplication printAllElements (MyFile.m:27)\n\nNSRangeException: \\*\\*\\* -\\[\\_\\_NSArrayI objectAtIndex:\\]: index 3 beyond bounds \\[0 .. 2\\]\n\n0 CoreFoundation      \\_\\_exceptionPreprocess + 124\n\n1 libobjc.A.dylib     objc\\_exception\\_throw + 52\n\n2 CoreFoundation      -\\[\\_\\_NSArrayI objectAtIndex:\\] + 180\n\n3 MyApplication       getElementFromArray (MyFile.m:22)\n\n4 MyApplication       printAllElements (MyFile.m:27)\n\nNow it’s pretty obvious that crash was caused by some improper array access in line 22 of MyFile.m, which happens to be within getElementsArray method. And if we need more context, we can easily see this one was called by printAllElements at line 27 of the same file.\n\nWhat is a dSYM file?\n--------------------\n\nLuckily for us, XCode can be instructed to keep a lot of the data that is being lost during the build process. It can put it inside the application itself, but that is not a good idea. We do not want to ship our application with all these extra debugging information, it will make it very easy for our competitors and hackers to reverse engineer the app. We would like to have it generated, but kept out of the AppStore. That’s exactly what dSYM file is all about. During the build process, XCode strips all the debug information from the main executable file, and puts it inside a special file called dSYM. This helps to keep our executable small and easier to distribute to happy customers.\n\nIf our application is using frameworks, the product folder will have a separate dSYM file generated for each framework built. Eventually all of them are needed if we want to cover our bases and be able to symbolicate a crash in every possible location in our app.\n\nNeedless to say, a dSYM file generated while building a specific version of the application can only be used to symbolicate crashes from that specific version only.  \ndSYM files are identified by a Unique ID (UUID), which changes every time we modify and rebuild our code, and that ID is what is used to match a symbol file to a specific crash. A dSYM may be associated with more than one UUID, as it may contain debug information for more than one architecture.\n\nThe UUID of a dSYM can be easily retrieved using the dwarfdump command:\n\n$ dwarfdump -u MyApplication.app.dSYM UUID: 9F665FD6-E70C-3EB9-8622-34FD9EC002CA (armv7) MyApplication.app.dSYM UUID: 8C2F9BB8-BB3F-37FE-A83E-7F2FF7B98889 (arm64) MyApplication.app.dSYM\n\n$ dwarfdump -u MyApplication.app.dSYM\n\nUUID: 9F665FD6-E70C-3EB9-8622-34FD9EC002CA (armv7) MyApplication.app.dSYM\n\nUUID: 8C2F9BB8-BB3F-37FE-A83E-7F2FF7B98889 (arm64) MyApplication.app.dSYM\n\nThe dSYM above has debug information for both arm7 and arm64 flavors of our application, each flavor has its own UUID.\n\nThese dSYM files can and should be manually stored for future symbolication of the crashes in the production build. Alternatively they can be uploaded to a crash reporting service like Bugsee, where they will be put in a vault and will get eventually used for processing a crash for that specific build. Typically, a special [build phase](https://docs.bugsee.com/sdk/ios/symbolication/) is added to the build process that is responsible for uploading dSYM files to the vault.\n\nWhat happens during iOS crash?\n------------------------------\n\nDuring crash the following information is being collected on the device:\n\n*   Crash/exception type and an exception specific message (if and when available)\n*   Stack trace for each thread (in raw form, the list of these unreadable return addresses that we saw before)\n*   List of all images (user and system frameworks and extensions loaded by the application. Each one has a unique UUID to help match it to the right dSYM file)\n*   Other information about the specific build, device, time of the crash, etc. These are less relevant to the symbolication process, but important nevertheless.\n\nThis information is sent for processing to the crash reporting service, where it will be matched with proper dSYM files that were already uploaded at build time, or will be uploaded manually at a later time. The symbolication process happens on the server and produces a nice, human readable crash report that can either be viewed through a web dashboard or downloaded as a file. The report will typically include the items listed above (basic info, crash/exception details and symbolicated stack trace if all the stars are aligned and all symbol files were properly uploaded and processed.\n\nThat is what a typical crash reporting service provides.  Bugsee provides much more than that, to name a few, with Bugsee, these reports also include an interactive player that can play in a synchronized manner the following:\n\n*   Video of the screen and user interactions that preceded the crash\n*   Network traffic, with complete request and response headers and body\n*   System and application traces (disk space, cpu loads, top view and window names, etc.)\n*   Your custom traces\n*   Console logs\n\nThis gives much more context that is of tremendous help when trying to debug an evasive issue that is only happening for customers in the field.\n\n_In the [next post](/blog/ios-crash-symbolication-dummies-part-2/) of the series, we are diving deeper into symbolication process itself, and show how to manually symbolicate an address or a full Apple crash report._",
  "next_page_url": null,
  "url": "https://www.bugsee.com/blog/ios-crash-symbolication-dummies-part-1/",
  "domain": "www.bugsee.com",
  "excerpt": "Many developers use Bugsee for its great crash reporting capabilities. In fact, Bugsee crash reporting has recently been ranked the highest among all iOS crash reporting services when it comes to&hellip;",
  "word_count": 1631,
  "direction": "ltr",
  "total_pages": 1,
  "rendered_pages": 1
}
